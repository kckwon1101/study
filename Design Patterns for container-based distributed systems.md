# Design Patterns for container-based distributed systems
syntax : [Link](https://www.usenix.org/conference/hotcloud16/workshop-program/presentation/burns)
<hr/>

## 1. Introduction
<hr/>
    1980년대 후반과 1990년대 초반에 객체 지향 프로그래밍은 소프트웨어 개발에 혁신을 일으켜 응용 프로그램 구축 방식을 모듈형 요소들의 집합으로 대중화했다. 오늘날 우리는 분산 시스템 개발에서도 유사한 혁명을 겪고 있으며, 컨테이너형 소프트웨어 구성 요소로 구축된 마이크로 서비스 아키텍처의 인기가 증가하고 있습니다. 컨테이너는 특히 컨테이너 경계에 설치된 벽 때문에 분산 시스템의 기본적인 "객체"로서 적합합니다. 이러한 건축 스타일이 발달함에 따라, 우리는 다양한 객체(또는 컨테이너)의 관점에서 다양한 객체(또는 컨테이너)가 나타나는 것처럼 디자인 패턴의 출현을 목격하게 됩니다.<br>

본 문서에서는 컨테이너 관리를 위한 단일 컨테이너 패턴, 밀접하게 협력하는 컨테이너의 단일 노드 패턴, 다중 노드 패턴 등 세가지 유형의 설계 패턴을 설명합니다. 앞에 있는 객체 지향 패턴과 마찬가지로, 분산 연산에 대한 이러한 패턴은 모범 사례를 인코딩하고, 개발을 단순화하며, 사용되는 시스템을 보다 안정적으로 만든다.


## 2. Distributed system design patterns
<hr/>
객체 지향 프로그래밍을 사용한 후 몇 년 동안, 설계 패턴이 나타나 문서화되었다. 이러한 패턴은 특정 공통 프로그래밍 문제를 해결하기 위한 일반 접근방식을 성문화하고 규칙화했다. 이 암호화는 덜 숙련된 프로그래머들이 잘 설계된 코드를 쉽게 만들 수 있도록 해주었고, 코드를 더 신뢰할 수 있고 더 빨리 개발할 수 있도록 하는 재사용 가능한 라이브러리의 개발을 이끌었기 때문에 프로그래밍에서 예술의 일반적인 상태를 더욱 개선시켰다.

오늘날 분산형 시스템 엔지니어링의 최첨단 기술은 객체 지향적 개발의 세계보다 1980년대 초반의 프로그래밍의 세계를 훨씬 더 닮아 있다. 그러나 MapReduce 패턴의 성공으로 "빅 데이터" 프로그래밍의 힘을 광범위한 분야와 개발자에게 제공함으로써, 적절한 패턴 세트를 배치하면 분산 시스템 프로그래밍의 품질, 속도 및 접근성을 획기적으로 향상시킬 수 있다는 것은 분명하다. 그러나 MapReduce의 성공조차도 Apache Hadoop 생태계가 주로 Java에 쓰이고 있는 한, 단일 프로그래밍 언어에 국한되어 있다. 분산형 시스템 설계를 위한 진정으로 포괄적인 패턴 제품군을 개발하려면 시스템의 원자를 나타내기 위해 매우 일반적인 언어 중립적인 차량이 필요하다.

따라서 지난 2년간 리눅스 컨테이너 기술의 채택이 극적으로 증가한 것은 다행스러운 일이다. 컨테이너와 컨테이너 이미지는 정확히 분산된 시스템 패턴의 개발에 필요한 추상화들이다. 현재까지, 컨테이너와 컨테이너 이미지는 단순히 개발로부터 생산까지 소프트웨어를 전달하기 위한 더 좋고, 더 신뢰할 수 있는 방법이 됨으로써 그들의 인기의 큰 척도를 달성했다. 은밀하게 봉인되고, 의존성을 지니고, 원자 배치 신호(*atomic deployment signal*)("succeeded"/"failed")를 제공함으로써, 데이터 센터나 클라우드에 소프트웨어를 배포하는 데 있어 이전의 기술 상태를 극적으로 개선한다. 하지만 컨테이너는 잠재력이 있다.
단순히 더 나은 배치 차량 이상의 것이 될 수 있음 – 우리는 그것들이 객체 지향 소프트웨어 시스템의 객체들과 유사하게 될 것이라고 믿으며, 그렇게 함으로써 분산된 시스템 설계 패턴의 개발을 가능하게 할 것이다. 다음 절에서는 이러한 경우를 왜 그렇게 생각하는지 설명하고, 향후 몇 년 동안 분산 시스템의 엔지니어링을 정규화하고 안내하기 위해 출현할 것으로 보이는 몇 가지 패턴을 설명한다.

## 3. Single-container management patterns
<hr/>
컨테이너는 객체 경계와 마찬가지로 인터페이스를 정의하기 위한 자연적인 경계를 제공한다. 컨테이너는 이 인터페이스를 통해 애플리케이션별 기능뿐만 아니라 관리 시스템에 대한 후크도 노출할 수 있다.

전통적인 컨테이너 관리 인터페이스는 극히 제한적이다. 컨테이너는 run(), pause() 및 stop()의 3개의 동사(*verbs*)를 효과적으로 내보낸다. 이 인터페이스는 유용하지만, 더 풍부한 인터페이스는 시스템 개발자와 운영자에게 훨씬 더 많은 효용성을 제공할 수 있다. 그리고 거의 모든 현대 프로그래밍 언어에서 HTTP 웹 서버에 대한 유비쿼터스 지원과 JSON과 같은 데이터 포맷에 대한 폭넓은 지원을 고려할 때, 컨테이너가 주요 기능 외에 특정 엔드포인트에서 웹 서버를 호스트하도록 함으로써 "실행(*implemented*)"할 수 있는 HTTP 기반 관리 API를 정의하는 것은 쉽다.

컨테이너는 "상향(*upward*)" 방향에서 애플리케이션별 모니터링 메트릭(QPS, 애플리케이션 상태 등), 개발자에게 관심 있는 정보 프로파일링(스레드, 스택, 잠금 경합(*lock contention*), 네트워크 메시지 통계 등), 구성요소 구성 정보 및 구성요소 로그를 노출할 수 있다. 이것의 구체적인 예로서, Kubernetes, Aurora, Marathon 및 기타 컨테이너 관리 시스템은 사용자가 지정된 HTTP 엔드포인트(예: "/health")를 통해 건강 점검을 정의할 수 있도록 한다. 우리가 설명한 "상향" API의 다른 요소에 대한 표준화된 지원은 더 드물다.

"하향(*downware*)" 방향에서, 컨테이너 인터페이스는 관리 시스템에 의해 제어되는 소프트웨어 구성요소를 쓰기 쉽게 하는 라이프사이클을 정의하는 자연스러운 장소를 제공한다. 예를 들어 클러스터 관리 시스템은 일반적으로 "우선순위(*priorities*)"를 작업에 할당하며, 클러스터가 과다 구독(*overscribed*)되더라도 높은 우선순위 작업이 실행되도록 보장한다. 이 보장은 이미 실행되고 있는 우선순위가 낮은 작업을 퇴출함으로써 시행되며, 그런 다음 자원이 이용가능해질 때까지 기다려야 한다. 퇴거(*eviction*)는 우선순위가 낮은 과제를 단순히 죽임으로써 실행될 수 있지만, 이것은 개발자에게 그들의 코드의 어느 곳에서도 임의의 죽음에 반응하는 과도한 부담을 준다. 대신에, 애플리케이션과 관리 시스템 사이에 공식적인 라이프사이클이 정의된다면, 애플리케이션 구성요소는 정의된 계약에 부합하기 때문에 관리가 더 쉬워지고, 개발자가 계약에 의존할 수 있기 때문에 시스템의 개발이 더 쉬워진다. 예를 들어, Kubernetes는 SIGTERM 신호를 통해 컨테이너가 종료될 것임을 경고하는 Docker의 "Graceful deletion" 기능을 사용하며, 이 기능은 SIGKILL 신호를 전송하기 전까지의 애플리케이션 정의 시간이다. 이를 통해 기내 작업(*in-flight operating*)을 완료하고 디스크로 플러싱하는 등의 방법으로 애플리케이션을 깨끗하게 종료할 수 있다. 이러한 메커니즘을 확장하여 상태 저장 분산 시스템의 상태 관리를 훨씬 쉽게 하는 상태 연속화 및 복구 지원을 제공하는 것을 상상할 수 있다.

보다 복잡한 라이프사이클의 구체적인 예로서, 일련의 콜백(예: onCreate()), onStart(), onStop(), ...) 및 시스템이 콜백을 트리거하는 방법에 대해 공식적으로 정의된 상태 기계(*a formally defined state machine*)를 특징으로 하는 안드로이드 활동 모델을 고려한다. 이러한 공식적인 라이프사이클이 없다면, 강력하고 신뢰할 수 있는 안드로이드 애플리케이션은 개발하기가 훨씬 더 어려울 것이다. 컨테이너 기반 시스템의 맥락에서, 이것은 컨테이너가 생성될 때, 그것이 시작되었을 때, 종료 직전에 호출되는 애플리케이션 정의(*applicationdefined*) 후크로 일반화된다. 컨테이너가 지원할 수 있는 "다운워드" API의 또 다른 예로는 "replicate yourself" (서비스 규모를 확대하기 위해)이다.




